sqlx의 쿼리 매크로(query!, query_as! 등)는 컴파일 타임에 데이터베이스와 연결해 SQL 쿼리를 정적으로 검증합니다.
이를 위해 컴파일 시점에 데이터베이스 접속 정보가 필요하고, 기본적으로 DATABASE_URL 환경변수가 설정되어 있어야 합니다.
또는 cargo sqlx prepare 명령을 실행해 쿼리를 미리 준비해 캐시(sqlx-data.json)를 만들어야 합니다.
이 파일이 있으면 컴파일 시 데이터베이스 연결 없이도 쿼리 검증이 가능합니다.


match arms의 타입 규칙이 다른가?
    -> imple Trait는 **어떤 구체 타입인지 숨긴다** 는 것이 목적이므로, 컴파일러도 그 타입이 정확히 뭔지 모른다. 따라서 서로 다른 impl Trait는 같은 타입인지 확이할 방법이 없다.
특징 / 구체 타입(Concrete Type)        VS        불투명 타입(Opaque Type)
컴파일러 인식 / 정확한 타입 알고 있음                   뭔가 트레이트 구현한 것
타입 비교 /    정확히 비교 가능                       비교 불가능
match arms / ✅ 같은 타입이면 OK                    ❌ 각각 다른 불투명 타입
예시 /        Ordering, Decimal                  impl Subscriber
해결책 /       필요 없음                            Box<dyn> 또는 분리
예외 continue와 !(never type)의 특별 한 경우
    -> continue의 타입은 !(never. type) !의 의미는 "이 코드는 절대 반환하지 않음"을 의미 !는 모든 타입으로 강제 변환(coercion) 가능


Rust의 Actix-web에서 정적 파일 라우트를 동적 라우트보다 먼저 등록해야 하는 이유는 라우트 매칭 순서 때문입니다.
핵심 이유
Actix-web은 등록된 순서대로 라우트를 매칭합니다. 먼저 등록된 라우트가 요청과 일치하면, 그 즉시 해당 핸들러를 실행하고 이후 라우트는 확인하지 않습니다.

라우팅 우선순위 원칙
1) 구체적인 경로 → 일반적인 경로 순서로 등록
2) 정적 → 동적 순서로 등록
3) Catch-all(default_service)은 항상 마지막
이렇게 하면 /css/style.css는 정적 파일 서비스가 처리하고, /tracing_basic은 동적 핸들러가 처리하며, 그 외는 404 핸들러가 처리합니다.


let nicknameChecked = false;

// 별명 중복 확인
async function checkNickname() {
    const nickname = document.getElementById('nickname').value.trim();
    const statusEl = document.getElementById('nicknameStatus');
    
    if (!nickname) {
        statusEl.textContent = '별명을 입력해주세요.';
        statusEl.style.color = 'var(--rust-orange)';
        return;
    }

    try {
        // 실제 API 호출 (예시)
        // const response = await fetch(`/api/check-nickname?nickname=${nickname}`);
        // const data = await response.json();
        
        // 임시 시뮬레이션
        const isAvailable = Math.random() > 0.5;
        
        if (isAvailable) {
            statusEl.textContent = '✓ 사용 가능한 별명입니다.';
            statusEl.style.color = '#059669';
            nicknameChecked = true;
        } else {
            statusEl.textContent = '✗ 이미 사용 중인 별명입니다.';
            statusEl.style.color = 'var(--rust-orange)';
            nicknameChecked = false;
        }
    } catch (error) {
        statusEl.textContent = '확인 중 오류가 발생했습니다.';
        statusEl.style.color = 'var(--rust-orange)';
        nicknameChecked = false;
    }
}

// 별명 입력 시 중복확인 상태 리셋
document.getElementById('nickname').addEventListener('input', function() {
    nicknameChecked = false;
    document.getElementById('nicknameStatus').textContent = '';
});

// 비밀번호 보기/숨기기
function togglePasswordVisibility() {
    const passwordInput = document.getElementById('password');
    const toggleIcon = document.getElementById('toggleIcon');
    
    if (passwordInput.type === 'password') {
        passwordInput.type = 'text';
        toggleIcon.textContent = '🙈 숨기기';
    } else {
        passwordInput.type = 'password';
        toggleIcon.textContent = '👁️ 보기';
    }
}

// 비밀번호 일치 확인
document.getElementById('passwordConfirm').addEventListener('input', function() {
    const password = document.getElementById('password').value;
    const passwordConfirm = this.value;
    const matchEl = document.getElementById('passwordMatch');
    
    if (!passwordConfirm) {
        matchEl.textContent = '';
        return;
    }
    
    if (password === passwordConfirm) {
        matchEl.textContent = '✓ 비밀번호가 일치합니다.';
        matchEl.style.color = '#059669';
    } else {
        matchEl.textContent = '✗ 비밀번호가 일치하지 않습니다.';
        matchEl.style.color = 'var(--rust-orange)';
    }
});

// 회원가입 처리
async function handleSignup(event) {
    event.preventDefault();
    
    // 별명 중복확인 여부
    if (!nicknameChecked) {
        alert('별명 중복 확인을 해주세요.');
        return;
    }
    
    // 비밀번호 일치 확인
    const password = document.getElementById('password').value;
    const passwordConfirm = document.getElementById('passwordConfirm').value;
    
    if (password !== passwordConfirm) {
        alert('비밀번호가 일치하지 않습니다.');
        return;
    }
    
    // 비밀번호 유효성 검사
    const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!%*#?&]{8,}$/;
    if (!passwordRegex.test(password)) {
        alert('비밀번호는 최소 8자 이상이며, 영문, 숫자, 특수문자를 포함해야 합니다.');
        return;
    }
    
    const formData = {
        email: document.getElementById('email').value,
        name: document.getElementById('name').value,
        nickname: document.getElementById('nickname').value,
        password: password
    };
    
    console.log('회원가입 데이터:', formData);
    
    try {
        // 실제 API 호출
        // const response = await fetch('/api/signup', {
        //     method: 'POST',
        //     headers: { 'Content-Type': 'application/json' },
        //     body: JSON.stringify(formData)
        // });
        
        alert('회원가입이 완료되었습니다!');
        window.close();
    } catch (error) {
        alert('회원가입 중 오류가 발생했습니다.');
    }
}