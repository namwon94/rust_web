sqlx의 쿼리 매크로(query!, query_as! 등)는 컴파일 타임에 데이터베이스와 연결해 SQL 쿼리를 정적으로 검증합니다.
이를 위해 컴파일 시점에 데이터베이스 접속 정보가 필요하고, 기본적으로 DATABASE_URL 환경변수가 설정되어 있어야 합니다.
또는 cargo sqlx prepare 명령을 실행해 쿼리를 미리 준비해 캐시(sqlx-data.json)를 만들어야 합니다.
이 파일이 있으면 컴파일 시 데이터베이스 연결 없이도 쿼리 검증이 가능합니다.


match arms의 타입 규칙이 다른가?
    -> imple Trait는 **어떤 구체 타입인지 숨긴다** 는 것이 목적이므로, 컴파일러도 그 타입이 정확히 뭔지 모른다. 따라서 서로 다른 impl Trait는 같은 타입인지 확이할 방법이 없다.
특징 / 구체 타입(Concrete Type)        VS        불투명 타입(Opaque Type)
컴파일러 인식 / 정확한 타입 알고 있음                   뭔가 트레이트 구현한 것
타입 비교 /    정확히 비교 가능                       비교 불가능
match arms / ✅ 같은 타입이면 OK                    ❌ 각각 다른 불투명 타입
예시 /        Ordering, Decimal                  impl Subscriber
해결책 /       필요 없음                            Box<dyn> 또는 분리
예외 continue와 !(never type)의 특별 한 경우
    -> continue의 타입은 !(never. type) !의 의미는 "이 코드는 절대 반환하지 않음"을 의미 !는 모든 타입으로 강제 변환(coercion) 가능


Rust의 Actix-web에서 정적 파일 라우트를 동적 라우트보다 먼저 등록해야 하는 이유는 라우트 매칭 순서 때문입니다.
핵심 이유
Actix-web은 등록된 순서대로 라우트를 매칭합니다. 먼저 등록된 라우트가 요청과 일치하면, 그 즉시 해당 핸들러를 실행하고 이후 라우트는 확인하지 않습니다.

라우팅 우선순위 원칙
1) 구체적인 경로 → 일반적인 경로 순서로 등록
2) 정적 → 동적 순서로 등록
3) Catch-all(default_service)은 항상 마지막
이렇게 하면 /css/style.css는 정적 파일 서비스가 처리하고, /tracing_basic은 동적 핸들러가 처리하며, 그 외는 404 핸들러가 처리합니다.