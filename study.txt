sqlx의 쿼리 매크로(query!, query_as! 등)는 컴파일 타임에 데이터베이스와 연결해 SQL 쿼리를 정적으로 검증합니다.
이를 위해 컴파일 시점에 데이터베이스 접속 정보가 필요하고, 기본적으로 DATABASE_URL 환경변수가 설정되어 있어야 합니다.
또는 cargo sqlx prepare 명령을 실행해 쿼리를 미리 준비해 캐시(sqlx-data.json)를 만들어야 합니다.
이 파일이 있으면 컴파일 시 데이터베이스 연결 없이도 쿼리 검증이 가능합니다.


match arms의 타입 규칙이 다른가?
    -> imple Trait는 **어떤 구체 타입인지 숨긴다** 는 것이 목적이므로, 컴파일러도 그 타입이 정확히 뭔지 모른다. 따라서 서로 다른 impl Trait는 같은 타입인지 확이할 방법이 없다.
특징 / 구체 타입(Concrete Type)        VS        불투명 타입(Opaque Type)
컴파일러 인식 / 정확한 타입 알고 있음                   뭔가 트레이트 구현한 것
타입 비교 /    정확히 비교 가능                       비교 불가능
match arms / ✅ 같은 타입이면 OK                    ❌ 각각 다른 불투명 타입
예시 /        Ordering, Decimal                  impl Subscriber
해결책 /       필요 없음                            Box<dyn> 또는 분리
예외 continue와 !(never type)의 특별 한 경우
    -> continue의 타입은 !(never. type) !의 의미는 "이 코드는 절대 반환하지 않음"을 의미 !는 모든 타입으로 강제 변환(coercion) 가능

//20251001
Rust의 Actix-web에서 정적 파일 라우트를 동적 라우트보다 먼저 등록해야 하는 이유는 라우트 매칭 순서 때문입니다.
핵심 이유
Actix-web은 등록된 순서대로 라우트를 매칭합니다. 먼저 등록된 라우트가 요청과 일치하면, 그 즉시 해당 핸들러를 실행하고 이후 라우트는 확인하지 않습니다.

라우팅 우선순위 원칙
1) 구체적인 경로 → 일반적인 경로 순서로 등록
2) 정적 → 동적 순서로 등록
3) Catch-all(default_service)은 항상 마지막
이렇게 하면 /css/style.css는 정적 파일 서비스가 처리하고, /tracing_basic은 동적 핸들러가 처리하며, 그 외는 404 핸들러가 처리합니다.

//20251015
현재 웹 개발 트렌드
1. SPA (Single Page Application) 방식이 주류
React, Vue, Svelte 등으로 화면 전환
페이지를 새로 로드하지 않고 컴포넌트만 교체
각 컴포넌트가 독립적인 생명주기를 가짐
2. 전통적인 MPA (Multi Page Application) 방식
페이지 이동 시 전체 HTML 새로 로드
각 페이지가 독립적인 script 실행
당신이 말한 방식이 바로 이것!
3. 모달/팝업은 점점 덜 선호되는 추세
UX 관점에서 방해가 됨
모바일에서 불편함
뒤로가기 버튼으로 닫을 수 없음

SPA(싱글 페이지 애플리케이션)에서 “컴포넌트”는 화면의 특정 영역이나 기능을 담당하는 독립적인 코드 단위로, 사용자가 페이지 내에서 상호작용할 때 각 컴포넌트가 바뀌거나 갱신되는 구조를 의미합니다.​

컴포넌트의 의미와 역할
SPA 방식에서 컴포넌트는 UI뿐 아니라 해당 영역의 로직, 상태 관리까지 포함하는 작은 앱 단위로 이해할 수 있습니다. 각각의 컴포넌트는 목적에 따라 화면을 렌더링하기 위한 코드와 상태 관리 코드를 가지고 있어, 페이지 전체를 새로 고치지 않고도 해당 컴포넌트만 교체하거나 갱신할 수 있습니다.​

컴포넌트의 독립적 생명주기
컴포넌트는 SPA 환경에서 각각 독립적인 생명주기를 가지며, 특정 이벤트나 데이터 변화에 따라 개별적으로 생성, 갱신, 소멸됩니다. 이러한 구조 덕분에 복잡한 페이지도 빠르고 동적으로 업데이트할 수 있어, 유지보수와 재사용성이 높아지고 사용자 경험이 개선됩니다.​

컴포넌트 기반 프레임워크
현대 SPA 개발에서는 React, Vue, Angular와 같은 프레임워크들이 컴포넌트 기반 개발 방식을 지원하고, 각 컴포넌트는 독립적으로 만들어져 전체 애플리케이션을 구성합니다. 이는 웹 애플리케이션을 화면 단위로 쪼개서 개발하고 관리할 수 있게 해줍니다

/api 접두사를 사용하는 이유
1. 명확한 구분 : 어떤 엔드포인트가 HTML을 반환하고, 어떤 것이 JSON을 반환하는지 명확함
2. 미들웨어 적용 쳔리
-------------------------------

fetch_optional(pool)
쿼리를 실행해서 0개 또는 1개의 결과 행(row)을 가져옵니다.

결과가 없으면 Ok(None)을 반환하고, 있으면 Ok(Some(레코드))를 반환합니다.

주로 검색(query)할 때, 결과가 없을 수도 있는 경우에 사용합니다.

반환 타입이 Result<Option<T>, E> 형태입니다.

execute(pool)
쿼리를 실행하고, 실제로 데이터베이스에 영향을 준 행(row)의 개수 등 실행 결과 상태만 반환합니다.

주로 INSERT, UPDATE, DELETE 등 데이터 변경 쿼리를 실행할 때 사용합니다.

반환 타입은 Result<sqlx::postgres::PgQueryResult, E> 등 실행 결과 객체입니다.

결과 행 데이터를 가져오지 않고, 영향을 준 행 수 등에만 관심 있을 때 쓰입니다.

//20251016
반환 타입 비교
login - Result<HttpResponse, InternalError<LoginError>>

에러를 명시적으로 처리하도록 강제
Actix-web의 에러 핸들링 시스템과 통합

register - HttpResponse

모든 경우를 함수 내에서 처리해서 항상 HttpResponse 반환
함수 내에서 에러 처리 로직이 노출됨

어느 것이 더 좋은가?
login 방식이 더 좋습니다. 이유는:
1. 관심사의 분리 - login 방식은 비즈니스 로직과 HTTP 응답 처리를 분리합니다. 핸들러 함수는 비즈니스 로직에만 집중하고, 에러를 Result로 반환하면 Actix-web의 에러 핸들러(impl ResponseError)가 HTTP 응답으로 변환하도록 위임합니다.
2. 재사용성 - 같은 로직을 gRPC, GraphQL 등 다른 프로토콜에서도 재사용할 수 있습니다. register 방식은 HTTP에 완전히 종속되어 있습니다.
3. 테스트 용이성 - 에러 타입이 명시적이어서 단위 테스트가 간단합니다.
4. 일관성 - Rust와 Actix-web 커뮤니티의 관례입니다.

//20251020
 방식의 차이를 설명하겠습니다.
let email = form.0.email; 는 form이 튜플 구조체이거나 튜플 타입일 때 사용합니다. .0은 튜플의 첫 번째 요소를 의미합니다.
let email = form.email; 는 form이 직접 FormData 구조체일 때 사용합니다.

정리하면:
form.0.email → form이 web::Form<FormData> 타입일 때 (튜플로 감싸져 있음)
form.email → form이 FormData 타입일 때 (직접 구조체)

함수 파라미터에서 web::Form(form) 처럼 unpacking 하면 두 번째 방식을 사용할 수 있습니다!


{%if cntn.is_some()%}
{%endif%}



**첫 번째 질문: `Ok(HttpResponse::Ok().content_type(ContentType::html()).body(rendered))`**

네, 맞습니다. 이 부분을 분석하면:

--------rust---------
HttpResponse::Ok()                           // HTTP 200 상태
    .content_type(ContentType::html())       // Content-Type: text/html 헤더 설정
    .body(rendered)                          // rendered (HTML 문자열)을 응답 본문으로 전송
-----------------------

즉, **서버가 HTML 문자열을 응답 본문에 담아서 보내는 것**입니다.

**두 번째 질문: `innerHTML`을 사용해야 하는 이유**

JavaScript에서:

--------------javascript---------------------
// 방법 1: response.json() - ❌ 실패
const result = await response.json();
// 서버에서 온 것: "<html><body>...</body></html>" (HTML 문자열)
// 하지만 이것을 JSON으로 파싱하려고 하니 구문 에러 발생!

// 방법 2: response.text() - ✅ 성공
const html = await response.text();
// 서버에서 온 것: "<html><body>...</body></html>" (HTML 문자열)
// HTML 문자열 그대로 받음

// 방법 3: innerHTML에 할당 - ✅ 렌더링
document.documentElement.innerHTML = html;
// HTML 문자열을 DOM으로 변환하여 브라우저가 렌더링
--------------------------

**시각적으로 설명:**

-------------------------
Rust 서버:
┌─────────────────────────────────┐
│ rendered = "<div>로그인 성공</div>" │
└────────────────────┬────────────┘
                     │
                     ↓ HTTP 응답
JavaScript 클라이언트:
┌─────────────────────────────────┐
│ const html = await response.text()
│ // html = "<div>로그인 성공</div>"
└────────────────────┬────────────┘
                     │
                     ↓
┌─────────────────────────────────┐
│ document.innerHTML = html;
│ // 브라우저가 HTML을 파싱하여 DOM으로 변환
│ // 화면에 "로그인 성공" 표시
└─────────────────────────────────┘
-------------------------------------

**정리:**

| 단계 | 설명 |
|------|------|
| **Rust** | HTML 문자열을 `body(rendered)`로 응답 전송 |
| **JavaScript 1** | `response.text()` → HTML 문자열 받기 |
| **JavaScript 2** | `innerHTML = html` → HTML 문자열을 DOM으로 렌더링 |

`response.json()`을 쓸 수 없는 이유는 **HTML은 JSON 형식이 아니기 때문**입니다!




**`#[derive(Deserialize, Serialize)]`는 자동으로 코드를 생성해주는 매크로입니다.**

-------------------rust-----------------
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize)]
pub struct User {
    email: String,
    name: String,
    age: u32,
}
-----------------------

**1. `Serialize` - Rust 구조체 → JSON으로 변환**

--------------rust------------------------
let user = User {
    email: "test@example.com".to_string(),
    name: "John".to_string(),
    age: 30,
};

// Serialize 덕분에 이게 가능
let json = serde_json::to_string(&user)?;
// 결과: {"email":"test@example.com","name":"John","age":30}
-----------------------------

**2. `Deserialize` - JSON → Rust 구조체로 변환**

-----------------------rust--------------------------
let json = r#"{"email":"test@example.com","name":"John","age":30}"#;

// Deserialize 덕분에 이게 가능
let user: User = serde_json::from_str(json)?;
// 결과: User { email: "test@example.com", name: "John", age: 30 }
-------------------------------

**정리:**

| 이름 | 기능 | 방향 |
|------|------|------|
| **Deserialize** | JSON → Rust 구조체 | 입력 (클라이언트 → 서버) |
| **Serialize** | Rust 구조체 → JSON | 출력 (서버 → 클라이언트) |

**둘 다 필요할 때:**

-------------------rust-----------------------------
#[derive(Deserialize, Serialize)]
pub struct User {
    email: String,
    name: String,
}

// 이 구조체를 JSON으로도 변환하고, JSON에서도 변환받을 수 있음
---------------------------------------------

//20251021
공부 목적이라면 **방식 2번 (JWT + Refresh Token in Redis)** 을 추천합니다.

## 추천 이유

### 1. **현대적이고 실무에서 가장 많이 사용**
- REST API 기반 프론트-백 분리 구조에 최적화
- 취업/이직 시 포트폴리오로 가장 유용
- 마이크로서비스 아키텍처로 확장 가능

### 2. **프론트엔드 학습에 유리**
- React/Vue 등에서 토큰 관리 경험 쌓을 수 있음
- Axios 인터셉터로 자동 토큰 갱신 구현 학습
- LocalStorage vs Cookie 선택 경험

### 3. **백엔드 학습 범위가 넓음**
```rust
// 배울 수 있는 것들:
- JWT 생성/검증 (jsonwebtoken crate)
- Redis 연동 (redis crate)
- 미들웨어 작성 (토큰 검증)
- 보안 (CORS, XSS, CSRF)
- 에러 처리 (토큰 만료, 갱신 로직)
```

### 4. **모바일 앱 확장 고려**
- 나중에 Flutter/React Native 공부 시 동일한 API 재사용
- 세션 방식은 모바일에서 불편함

## 구현 난이도 비교

**세션(현재 코드)**: ⭐⭐ (가장 쉬움)
- actix-session이 대부분 처리

**JWT만**: ⭐⭐⭐ (중간)
- 토큰 생성/검증만 구현

**JWT + Refresh**: ⭐⭐⭐⭐ (약간 복잡하지만 학습 가치 높음)
- 토큰 2개 관리, 갱신 로직, Redis 연동

## 학습 로드맵 제안

1. **현재 세션 방식으로 기본 완성** (이미 구현됨)
2. **JWT만 사용하는 방식으로 리팩토링** (간단한 버전)
3. **Refresh Token + Redis 추가** (완성형)

이렇게 단계적으로 학습하면 각 방식의 장단점을 몸으로 체득할 수 있어서 면접에서도 자신있게 설명할 수 있습니다.